package algorithm2;

import java.util.*;

public class exam9_1 {
	int[] dx = {-1,0,1,0};
	int[] dy = {0,1,0,-1};
//	10. 봉우리
//	설명
//
//	지도 정보가 N*N 격자판에 주어집니다. 각 격자에는 그 지역의 높이가 쓰여있습니다.
//
//	각 격자판의 숫자 중 자신의 상하좌우 숫자보다 큰 숫자는 봉우리 지역입니다. 봉우리 지역이 몇 개 있는 지 알아내는 프로그램을 작성하세요.
//
//	격자의 가장자리는 0으로 초기화 되었다고 가정한다.
//
//	만약 N=5 이고, 격자판의 숫자가 다음과 같다면 봉우리의 개수는 10개입니다.
//
//	Image1.jpg
//
//
//	입력
//	첫 줄에 자연수 N이 주어진다.(2<=N<=50)
//
//	두 번째 줄부터 N줄에 걸쳐 각 줄에 N개의 자연수가 주어진다. 각 자연수는 100을 넘지 않는다.
//
//
//	출력
//	봉우리의 개수를 출력하세요.
//
//
//	예시 입력 1 
//
//	5
//	5 3 7 2 3
//	3 7 1 6 1
//	7 2 5 3 4
//	4 3 6 4 1
//	8 7 3 5 2
//	예시 출력 1
//
//	10
	
	
	
	//너무 무식하게 짰었다 코딩좀 한다 할려고 하면 이런 격자 판에서 위의 값, 아랫값, 왼쪽값, 오른쪽 값 조회 할 때 방향 배열을 만들어서 다룬다 배열이 하나여도 그 인덱스로 접근 못할상황이 생기는데
		//방향이란것은 정해져 있고, 선택지이니까 그것을 배열로 선언해 두는 것이지.
		
		//인덱스 배열을 선언해서 가운데 그 인덱스 배열에서 유도된 방향으로 그 인덱스를 만들어 주고 돌린다.
		
		//-> 시계 방향으로 돌리는 예시 
		/* 행 인덱스 좌표 배열 */
		// int [] dx = {-1(행 위로 한칸) , 0 (우측 세시 방향 행그대로), +1(6시 아래칸 행 추가) , 0(좌측 9시 행그대로)
		
		/* 열 인덱스 좌표 배열 */
		// int [] dx = {0(행만 움직여야 12시 지목 가능 그대로) , +1 (우측 세시 방향 으로 이동), 0(아래칸으로 행만 이동해야함 가만히) , -1(좌측 9시 행그대로 열이동)
		
		//그리고 1차로 i 포문 이ㅏ로 j 포문 돌리면서 arr[i][j] 로 그 격자판의 지점을 찍어서
		
		//여기서 이제 삼중 포문으로 돌리면서 인덱스 배열로 삼중 포문 차수마다 12로 이동시켜서 arr[i][j]랑 비교해보고
		//3시로 이동해서 arr[i][j]랑 비교해 보고 하는 것이다.
		
		//비교 해보고 반복문 돌다가 하나라도 이동한 지점의 값이 arr[i][j]보다 큰게 나오면 break로 끊어 버려
		
		//이미 봉우리 아니니까 찾아볼 필요 자체가 없어짐
	public static void main(String[] args) {
		
		
		exam9_1 exam7 = new exam9_1();
		
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int [][] arr = new int [n][n];
		for(int i =0; i < n; i++) {
			
			for(int j = 0; j < n; j++) {
				arr[i][j] = in.nextInt();
			}
		}
		System.out.println(exam7.solution(arr));
		
	}
	
	public int  solution(int [][] arr) {
		
		int answer = 0;
		
		for(int i = 0; i < arr.length; i++) {
			for(int j = 0; j < arr.length; j++) {
				boolean flag = true;
				for(int k = 0; k < dx.length; k++) {
					int r_index = i + dx[k];
					int c_index = j + dy[k];
					int around_num = arr[r_index][c_index];
					
					//여기에 각 모퉁이 가 방향 선택지에 포함되는 부분은 봉우리 조건이 성립 하지 않으니까 
					//행의 인덱스 범위 조건 에 맞는 제약 열의 인덱스 범위 조건에 맞는 제약을 주어야 한다.
					//사방의 값중에 같은게 있기만 해도 봉우리 조건은 성립 안되니까 크거나 같으면 으로 들어간다.
					//무작정 인덱스로 이동시켜버리면 기존 배열의 인덱스를 벗어 날 수 있기 때문에 각 배열의 길이 범위에 맞게 초기화 해주어야 한다.
					if(r_index >= 0 && r_index < arr[i].length && c_index >= 0 && c_index < arr[i].length - 1 && around_num >= arr[i][j]) {
						flag = false;
						break;
					}
				}
				if(flag) {
					answer ++;
				}
			}
		}
		return answer;
	}	
}
